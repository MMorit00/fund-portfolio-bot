# v0.5.1 AI ReAct 循环 - 技术设计报告

> **生成日期**：2025-12-26
> **版本**：v0.5.1
> **状态**：规划中
> **参考实现**：opencode 项目 ReAct 架构

---

## 1. 执行摘要

升级 AI 架构到 **ReAct (Reasoning + Acting) 循环模式**，支持多轮思考决策。

### 核心决策

| 决策项 | 结论 | 核心理由 |
|--------|------|----------|
| **循环架构** | 双层循环 | 外层管 step，内层管流式处理 |
| **终止机制** | finish_reason + max_steps | 自然结束 + 硬限制 |
| **状态管理** | Part 级状态机 | 细粒度恢复，支持审计 |
| **容错机制** | 指数退避 + Doom Loop 检测 | API 自动重试 + 成本控制 |
| **上下文优化** | 合成消息 + 压缩（可选） | 引导聚焦 + 防溢出 |

---

## 2. 架构对比

### v0.5.0 当前架构（单轮决策）

```
用户提问
    ↓
AI.chat()  → 一次性决定工具调用
    ↓
执行工具（并行）
    ↓
AI.chat()  → 返回答案
    ↓
END（最多 2 轮）
```

**限制**：
- 无法根据中间结果调整策略
- 不支持多步推理
- 无状态管理和容错

---

### v0.5.1 ReAct 循环架构

```
用户提问
    ↓
┌─────────────────────────────────────────────────┐
│            外层循环 (Step Manager)               │
│                                                 │
│  step = 0                                       │
│  while (step < MAX_STEPS):  ← 最多 15 步        │
│    step++                                       │
│    │                                            │
│    ├─ 检查终止条件：                             │
│    │    • finish_reason == "stop" → break      │
│    │    • step >= MAX_STEPS → break            │
│    │                                            │
│    └─ 进入内层处理 ↓                             │
│                                                 │
│  ┌───────────────────────────────────────────┐  │
│  │      内层处理 (Stream Processor)          │  │
│  │                                           │  │
│  │  while (retry < MAX_RETRY):              │  │
│  │    try:                                  │  │
│  │      stream = LLM.stream(messages)       │  │
│  │      for event in stream:                │  │
│  │        ├─ "text-delta" → 累积文本         │  │
│  │        ├─ "tool-call" → 执行 → Part      │  │
│  │        ├─ "tool-result" → 存储 → Part    │  │
│  │        └─ "finish-step" → continue/stop  │  │
│  │                                           │  │
│  │    except APIError:                      │  │
│  │      if retryable: sleep + retry         │  │
│  │      else: return "stop"                 │  │
│  │                                           │  │
│  │  [Doom Loop 检测]                         │  │
│  │    if 最近 3 次参数相同: 触发警告          │  │
│  │                                           │  │
│  └───────────────────────────────────────────┘  │
│                                                 │
│  [状态持久化] Part 对象存储                      │
│  [合成消息] 工具输出后注入引导                   │
│                                                 │
└─────────────────────────────────────────────────┘
    ↓
返回答案
```

---

## 3. 核心组件设计

### 3.1 Part 状态机

```
┌──────────┐
│ pending  │  ← 工具调用已发起，等待执行
└────┬─────┘
     │ tool-call
┌────▼──────┐
│ running   │  ← 工具正在执行
└────┬──────┘
     │ tool-result / tool-error
┌────▼─────────┬───────────┐
│ completed    │   error   │
└──────────────┴───────────┘
```

**Part 数据结构**：
```python
class Part:
    id: str
    session_id: str
    message_id: str
    type: Literal["text", "tool", "reasoning"]

    # 工具类型 Part
    tool: str | None
    state: ToolState | None  # {status, input, output}
```

---

### 3.2 循环终止条件

| 条件 | 触发时机 | 处理逻辑 |
|------|----------|----------|
| **finish_reason="stop"** | 模型返回完成信号 | 正常退出 |
| **step >= MAX_STEPS** | 达到最大步数（15） | 强制退出，注入提醒消息 |
| **Doom Loop 检测** | 同参数工具调用 3 次 | 拒绝执行 / 警告 |
| **API 不可恢复错误** | 认证失败、4xx 错误 | 立即退出 |

---

### 3.3 容错机制

#### 指数退避重试

```python
def retry_with_backoff(attempt: int) -> int:
    """计算等待时间（毫秒）"""
    base = 1000  # 1 秒
    factor = 2
    max_delay = 10000  # 最大 10 秒

    delay = base * (factor ** (attempt - 1))
    return min(delay, max_delay) + random.randint(0, 1000)
```

**可重试错误**：
- `RateLimitError` (429)
- `APITimeoutError`
- `APIError` (status >= 500)

**不可重试**：
- 认证错误 (401)
- 参数错误 (400)
- 资源不存在 (404)

---

#### Doom Loop 检测

```python
DOOM_LOOP_THRESHOLD = 3

def is_doom_loop(recent_calls: list[ToolCall]) -> bool:
    """检测是否陷入循环"""
    if len(recent_calls) < DOOM_LOOP_THRESHOLD:
        return False

    last_three = recent_calls[-3:]

    # 检查：同一工具 + 相同参数
    return all(
        call.tool == last_three[0].tool and
        call.input == last_three[0].input
        for call in last_three
    )
```

---

### 3.4 上下文优化

#### 合成消息注入

工具执行后自动添加引导消息：

```python
def inject_synthetic_message(tool_output: str) -> Message:
    """工具输出后注入"""
    return Message(
        role="user",
        content=f"Based on the tool output above, continue with your task.",
        synthetic=True  # 标记为合成消息
    )
```

#### 消息压缩（可选）

```
┌──────────────────────────────────────────┐
│           压缩策略（双层）                │
├──────────────────────────────────────────┤
│  Prune（轻量）：                          │
│    • 保留最近 40,000 Token 完整内容       │
│    • 更早的仅保留调用记录 + 标题          │
│                                          │
│  Compaction（全量）：                     │
│    • Token 超限时触发                     │
│    • 调用 LLM 总结历史                    │
│    • 保留最近 N 条完整消息                │
└──────────────────────────────────────────┘
```

---

## 4. 代码实现

### 4.1 目录结构

```
src/ai/
  ├─ client.py              # 现有：单轮 chat()
  ├─ loop.py                # 新增：ReAct 循环
  ├─ state.py               # 新增：Part 状态管理
  ├─ retry.py               # 新增：重试逻辑
  └─ prompts/
      └─ react.py           # 新增：ReAct 提示词模板
```

---

### 4.2 核心接口

```python
# src/ai/loop.py

class ReactLoop:
    """ReAct 循环管理器"""

    def __init__(
        self,
        client: AIClient,
        max_steps: int = 15,
        enable_retry: bool = True,
        enable_doom_detection: bool = True
    ):
        self.client = client
        self.max_steps = max_steps
        self.enable_retry = enable_retry
        self.enable_doom_detection = enable_doom_detection
        self.parts: list[Part] = []

    async def run(self, query: str) -> str:
        """
        执行 ReAct 循环

        Returns:
            最终答案
        """
        messages = self._build_initial_messages(query)

        # 外层循环：step 管理
        for step in range(self.max_steps):
            # 检查终止条件
            if self._should_stop(messages):
                break

            # 内层处理：流式 + 重试
            result = await self._process_step(messages, step)

            if result == "stop":
                break

        return self._extract_final_answer(messages)

    async def _process_step(
        self,
        messages: list[Message],
        step: int
    ) -> Literal["continue", "stop"]:
        """
        处理单个 step

        包含：
        - 流式响应处理
        - 工具调用
        - 错误重试
        - Doom Loop 检测
        """
        retry_count = 0

        while retry_count < 3:
            try:
                stream = await self.client.stream(messages)

                async for event in stream:
                    if event.type == "tool-call":
                        # Doom Loop 检测
                        if self._is_doom_loop(event):
                            raise DoomLoopError()

                        # 执行工具
                        output = await self._execute_tool(event)

                        # 存储 Part
                        self._add_part(Part(
                            type="tool",
                            tool=event.tool,
                            state={"status": "completed", "output": output}
                        ))

                    elif event.type == "finish-step":
                        return event.next  # "continue" or "stop"

            except (RateLimitError, APITimeoutError) as e:
                if not self.enable_retry:
                    raise

                retry_count += 1
                await self._sleep_with_backoff(retry_count)
                continue

        return "continue"
```

---

### 4.3 ReAct 提示词

```python
# src/ai/prompts/react.py

REACT_SYSTEM_PROMPT = """
# Role: 基金投资分析助手（ReAct 模式）

## 工作模式

你将按照 Think → Act → Observe 的循环流程工作：

1. **Think (思考)**：分析当前任务，决定下一步需要什么信息
2. **Act (行动)**：调用工具获取数据
3. **Observe (观察)**：分析工具返回结果，决定是否需要更多信息

## 循环终止条件

当你收集到足够信息后，返回 Final Answer。

## 示例

User: 上个月定投怎么样？有哪些异常？

Think: 需要先查询定投记录
Act: get_action(fund_code="001551", period="1m")
Observe: 返回 10 条记录，发现 2 条金额异常

Think: 异常可能是限额导致，需要查限额信息
Act: get_restriction(fund_code="001551", date="2024-11-15")
Observe: 返回"单日限额 2000 元"

Think: 已收集足够信息，可以给出完整分析
Final Answer: 共 10 次定投，2 次因限额导致部分成交...

## 约束

- 每次只调用 1-2 个工具
- 最多 15 步，合理规划查询策略
- 不编造数据，所有结论基于工具返回
"""
```

---

## 5. 实施范围

### 核心功能

- [x] v0.5.0 基础架构（已完成）
- [ ] 双层循环架构（外层 step + 内层流处理）
- [ ] Part 状态机（pending → running → completed/error）
- [ ] 指数退避重试
- [ ] Doom Loop 检测
- [ ] ReAct 提示词模板

### 可选增强

- [ ] 合成消息注入
- [ ] 消息压缩（Prune + Compaction）
- [ ] Snapshot Diffing（感知工具副作用）

---

## 6. 向后兼容

v0.5.0 的 `AIClient.chat()` 保持不变，新增 `ReactLoop` 类：

```python
# 兼容 v0.5.0（单轮）
client = AIClient()
response = client.chat("查询净值")

# 使用 v0.5.1（ReAct）
loop = ReactLoop(client)
response = await loop.run("查询净值")
```

CLI 通过参数选择：

```bash
# 单轮模式（默认）
uv run python -m src.cli.ai "查询定投"

# ReAct 模式
uv run python -m src.cli.ai "查询定投" --mode react
```

---

## 7. 风险与缓解

| 风险 | 可能性 | 缓解方案 |
|------|--------|----------|
| **循环不终止** | 中 | max_steps 硬限制 + Doom Loop 检测 |
| **成本增加** | 中 | 默认 15 步限制，可配置降低 |
| **状态管理复杂** | 中 | 简化 Part 结构，仅存储必要字段 |
| **API 频繁失败** | 低 | 指数退避 + 最大重试次数 |

---

## 8. 参考资料

- opencode 项目：`/Users/panlingchuan/Downloads/My_Project/opencode`
  - `packages/opencode/src/session/prompt.ts:242` - 外层循环
  - `packages/opencode/src/session/processor.ts:42` - 内层处理
  - `packages/opencode/src/session/retry.ts` - 重试机制
- ReAct 论文：[Synergizing Reasoning and Acting in Language Models](https://arxiv.org/abs/2210.03629)

---

## 9. 开发提示

> **当实现过程中遇到困惑时，看看 opencode 的源码怎么实现的**

### 常见问题 → 参考位置

| 问题 | 查看文件 | 关键代码位置 |
|------|----------|--------------|
| **如何组织双层循环？** | `prompt.ts` | 第 242 行 `while (true)` |
| **如何处理流式事件？** | `processor.ts` | 第 42-405 行 `process()` |
| **tool-call 如何触发执行？** | `processor.ts` | 第 122 行 `case "tool-call"` |
| **如何实现 Doom Loop 检测？** | `processor.ts` | 第 140-178 行检测逻辑 |
| **重试逻辑如何设计？** | `retry.ts` | `retryable()` + `delay()` |
| **消息如何压缩？** | `compaction.ts` | `isOverflow()` + Prune |
| **Part 状态如何更新？** | `processor.ts` | `Session.updatePart()` |

### 快速查看命令

```bash
# 查看外层循环逻辑
cat /Users/panlingchuan/Downloads/My_Project/opencode/packages/opencode/src/session/prompt.ts | grep -A 50 "while (true)"

# 查看工具调用处理
cat /Users/panlingchuan/Downloads/My_Project/opencode/packages/opencode/src/session/processor.ts | grep -A 30 "tool-call"

# 查看重试逻辑
cat /Users/panlingchuan/Downloads/My_Project/opencode/packages/opencode/src/session/retry.ts
```

### 调试技巧

1. **理解事件流**：在 `processor.ts` 中找到所有 `case` 分支，理解每种事件的处理逻辑
2. **跟踪状态变化**：搜索 `updatePart` 调用，了解状态如何持久化
3. **学习错误处理**：查看 `try-catch` 块如何区分可重试和不可重试错误
4. **参考测试用例**：查看 `__tests__` 目录了解边界情况

---

**文档结束**
