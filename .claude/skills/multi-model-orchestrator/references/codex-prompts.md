# Codex Prompt 模板库

专门用于 Codex 模型（GPT-5.2 high reasoning）的 prompt 模板。

**核心原则：要求展示完整推理过程**

---

## 基础验证

### 逻辑验证

```
验证以下代码/逻辑的正确性：

{code_or_logic}

请完整分析：
1. 逻辑是否完整（每个分支）
2. 边界情况（空值、极值、异常输入）
3. 潜在的运行时错误
4. 并发安全性（如适用）

**请展示完整推理过程。**
```

### 算法审查

```
审查以下算法实现：

{algorithm_code}

请分析：
1. 时间复杂度（最好/平均/最坏）
2. 空间复杂度
3. 是否有更优解法
4. 边界情况的测试用例

**请展示推理过程。**
```

### 方案评估

```
评估以下技术方案：

{proposal}

请分析：
1. 优点和缺点
2. 潜在风险和失败场景
3. 实现复杂度
4. 替代方案对比

**请给出完整推理。**
```

---

## 高级验证

### 代码质量关卡

```
作为最终质量关卡，验证以下代码：

{code_content}

请全面审查：
1. 逻辑正确性（核心逻辑、分支处理、边界情况）
2. 健壮性（异常处理、输入验证、错误恢复）
3. 性能（明显问题、复杂度、重复计算）
4. 并发安全（竞态、锁、死锁）
5. 可维护性（逻辑清晰、维护陷阱、最佳实践）

**输出**：
- ✅ 通过 - 可以合并
- ⚠️ 有建议 - 列出改进点
- ❌ 不通过 - 列出阻塞问题

**请展示推理过程。**
```

### 并发/竞态条件分析

```
分析以下代码的并发安全性：

{concurrent_code}

请推理分析：
1. 识别共享状态（哪些可变状态被多线程访问）
2. 竞态条件（列出可能的竞态场景，用"线程A执行X，同时线程B执行Y"描述）
3. 同步机制（锁是否足够、死锁可能、活锁/饥饿）
4. 数据一致性（原子性、可见性、有序性）
5. 修复建议（针对每个问题）

**请展示完整推理链条，包括所有可能的执行交错。**
```

### 性能瓶颈推理

```
推理分析以下代码的性能瓶颈：

{code_with_perf_issue}

背景：{性能问题描述}

请推理：
1. 热路径识别（频繁执行的代码、调用次数）
2. 复杂度分析（每个操作的复杂度、总复杂度）
3. 瓶颈推理（根据复杂度推理瓶颈点、为什么是瓶颈）
4. 资源使用（内存分配、I/O操作、缓存效率）
5. 优化建议（针对瓶颈的方案、优化后复杂度、收益代价）

**请展示推理过程，用数字和场景说明。**
```

### 重构前后对比

```
验证重构前后的行为一致性：

原实现：
{old_code}

新实现：
{new_code}

请对比：
1. 核心逻辑（算法、分支、输出）
2. 边界情况（列出所有边界、对比处理方式）
3. 副作用（状态修改、外部调用、事件触发）
4. 性能（时间/空间复杂度变化）
5. 风险评估（行为不一致风险、需要的测试）

**输出**：
- ✅ 等价 - 重构安全
- ⚠️ 需验证 - 列出需测试的场景
- ❌ 不等价 - 列出差异点

**请展示对比推理。**
```

---

## 使用指南

### 核心原则

| 原则 | 说明 |
|-----|------|
| 要推理 | 推理过程比结论重要 |
| 要完整 | 不限字数，保留推理步骤 |
| 去噪音 | 只移除 metadata 和客套话 |

### 何时使用

| 场景 | 模板 |
|-----|------|
| 一般逻辑检查 | 逻辑验证 |
| 算法复杂度 | 算法审查 |
| 技术决策 | 方案评估 |
| 合并前验证 | 代码质量关卡 |
| 多线程代码 | 并发/竞态分析 |
| 性能问题 | 性能瓶颈推理 |
| 重构验证 | 重构前后对比 |

### 输出处理（Haiku 执行）

**必须移除**：
- clink 的 metadata (duration, return_code)
- 开场白和结束语客套话

**必须保留**：
- 完整的推理链条（最重要）
- 所有发现的问题
- 边界情况说明
- 修复建议和代码示例
